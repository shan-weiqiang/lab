#include "my_message.pb.h" // Generated by protoc
#include <absl/strings/string_view.h>
#include <google/protobuf/compiler/importer.h>
#include <google/protobuf/compiler/parser.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/dynamic_message.h>
#include <google/protobuf/text_format.h>
#include <iomanip>
#include <iostream>
#include <memory>

using namespace std;

// Custom SourceTree for in-memory .proto files
class MemorySourceTree : public google::protobuf::compiler::SourceTree {
public:
  MemorySourceTree(const std::string &name, const std::string &content)
      : filename_(name), content_(content) {}

  google::protobuf::io::ZeroCopyInputStream *
  Open(absl::string_view filename) override {
    if (filename != filename_)
      return nullptr;
    return new google::protobuf::io::ArrayInputStream(
        content_.data(), static_cast<int>(content_.size()));
  }

private:
  std::string filename_;
  std::string content_;
};


int main() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  // ============================================
  // Section 1: Static Message Creation
  // Demonstrates creating a message using the generated C++ class
  // This is the most common and straightforward way to use protobuf
  // ============================================
  test::MyMessage static_msg;
  static_msg.set_id(123);
  static_msg.set_name("Static Message");

  cout << "\n=== Section 1: Static Message Creation ===\n";
  cout << "----------------------------------------\n";
  cout << "Message Content:\n" << static_msg.DebugString();
  cout << "Type: " << static_msg.GetTypeName() << "\n\n";

  // ============================================
  // Section 2: Dynamic Message Creation
  // Shows how to create a message using the descriptor and reflection APIs
  // This is useful when you don't have the generated C++ class at compile time
  // ============================================
  const google::protobuf::Descriptor *descriptor =
      google::protobuf::DescriptorPool::generated_pool()->FindMessageTypeByName(
          "test.MyMessage");

  if (!descriptor) {
    cerr << "Descriptor not found!" << endl;
    return 1;
  }

  google::protobuf::Message *dynamic_msg =
      google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(descriptor)
          ->New();

  // ============================================
  // Section 3: Type Identity Verification
  // Proves that static and dynamic messages are of the same type
  // Demonstrates that dynamic messages can be cast to their static counterparts
  // ============================================
  cout << "\n=== Section 3: Type Identity Verification ===\n";
  cout << "-------------------------------------------\n";
  cout << "Are descriptors identical? "
       << (descriptor == test::MyMessage::descriptor() ? "YES" : "NO") << "\n";

  test::MyMessage *converted_msg = dynamic_cast<test::MyMessage *>(dynamic_msg);
  cout << "Dynamic cast successful? " << (converted_msg ? "YES" : "NO")
       << "\n\n";

  // ============================================
  // Section 4: Memory Compatibility Test
  // Shows that dynamic messages can be modified and accessed just like static
  // ones Demonstrates the memory layout compatibility between static and
  // dynamic messages
  // ============================================
  cout << "\n=== Section 4: Memory Compatibility Test ===\n";
  cout << "------------------------------------------\n";

  // Set the same values in dynamic_msg as in static_msg
  const google::protobuf::Reflection *compat_reflection =
      dynamic_msg->GetReflection();
  const google::protobuf::Descriptor *compat_desc =
      dynamic_msg->GetDescriptor();

  const google::protobuf::FieldDescriptor *compat_id_field =
      compat_desc->FindFieldByName("id");
  const google::protobuf::FieldDescriptor *compat_name_field =
      compat_desc->FindFieldByName("name");

  compat_reflection->SetInt32(dynamic_msg, compat_id_field, static_msg.id());
  compat_reflection->SetString(dynamic_msg, compat_name_field,
                               static_msg.name());

  cout << "Static message content:\n" << static_msg.DebugString() << "\n";
  cout << "Dynamic message content:\n" << dynamic_msg->DebugString() << "\n";

  // Compare serialized values
  string compat_static_serialized, compat_dynamic_serialized;
  static_msg.SerializeToString(&compat_static_serialized);
  dynamic_msg->SerializeToString(&compat_dynamic_serialized);

  cout << "Serialized values identical? "
       << (compat_static_serialized == compat_dynamic_serialized ? "YES" : "NO")
       << "\n";
  if (compat_static_serialized != compat_dynamic_serialized) {
    cout << "Static serialized size: " << compat_static_serialized.size()
         << "\n";
    cout << "Dynamic serialized size: " << compat_dynamic_serialized.size()
         << "\n";
  }
  cout << "\n";

  // ============================================
  // Section 5: Basic Reflection API Usage
  // Demonstrates how to use the reflection API to access message fields
  // Shows the basic operations for getting and setting field values
  // ============================================
  test::MyMessage message;
  const google::protobuf::Reflection *reflection = message.GetReflection();
  const google::protobuf::Descriptor *descriptor_message =
      message.GetDescriptor();
  const google::protobuf::FieldDescriptor *id_field =
      descriptor_message->FindFieldByName("id");

  int32_t id_value = reflection->GetInt32(message, id_field);
  reflection->SetInt32(&message, id_field, 42);
  cout << "\n=== Section 5: Basic Reflection API Usage ===\n";
  cout << "-------------------------------------------\n";
  cout << "Message ID after reflection: " << message.id() << "\n\n";

  delete dynamic_msg; // Must manage dynamic allocation
  google::protobuf::ShutdownProtobufLibrary();

  // ============================================
  // Section 6: Dynamic Message Type Creation
  // Shows how to create a new message type programmatically
  // Useful for creating message types at runtime without .proto files
  // ============================================
  cout << "\n=== Section 6: Dynamic Message Type Creation ===\n";
  cout << "----------------------------------------------\n";
  google::protobuf::DescriptorPool pool(google::protobuf::DescriptorPool::generated_pool());
  google::protobuf::FileDescriptorProto file_proto;
  file_proto.set_name("my_dynamic.proto");
  file_proto.set_package("mypackage");

  google::protobuf::DescriptorProto *message_proto =
      file_proto.add_message_type();
  message_proto->set_name("MyDynamicMessage");

  google::protobuf::FieldDescriptorProto *field = message_proto->add_field();
  field->set_name("my_field");
  field->set_number(1);
  field->set_type(google::protobuf::FieldDescriptorProto::TYPE_STRING);

  const google::protobuf::FileDescriptor *file_desc =
      pool.BuildFile(file_proto);
  if (!file_desc) {
    std::cerr << "Failed to build file descriptor!" << std::endl;
    return 1;
  }

  const google::protobuf::Descriptor *message_desc = file_desc->message_type(0);
  if (!message_desc) {
    std::cerr << "Failed to get message descriptor!" << std::endl;
    return 1;
  }

  google::protobuf::DynamicMessageFactory factory;
  google::protobuf::Message *message_dyn =
      factory.GetPrototype(message_desc)->New();

  const google::protobuf::Reflection *dyn_reflection =
      message_dyn->GetReflection();
  const google::protobuf::FieldDescriptor *field_desc =
      message_desc->FindFieldByName("my_field");

  dyn_reflection->SetString(message_dyn, field_desc,
                            "Hello from dynamic message!");
  std::string value = dyn_reflection->GetString(*message_dyn, field_desc);
  std::cout << "Dynamic message field value: " << value << std::endl;

  // Without this, there will be seg fault; this is a because the underlyting
  // derived type is not protoc generated c++ class type anymore, it's
  // DynamicMessage type, the reason is unknown
  google::protobuf::UnknownFieldSet *unknown =
      message_dyn->GetReflection()->MutableUnknownFields(message_dyn);
  if (unknown) {
    unknown->AddVarint(999999, 0);
  }
  std::cout << message_dyn->DebugString() << std::endl;

  // ============================================
  // Section 7: Proto File String Parsing
  // Demonstrates how to create message types from a .proto file content string
  // Shows how to use the compiler infrastructure to parse proto definitions
  // ============================================
  cout << "\n=== Section 7: Proto File String Parsing ===\n";
  cout << "------------------------------------------\n";
  std::string proto_content = R"(
        syntax = "proto3";
        package dynamic;
        
        message DynamicPerson {
            string name = 1;
            int32 age = 2;
            repeated string hobbies = 3;
            bool is_active = 4;
        }
    )";

  google::protobuf::DescriptorPool descriptor_pool(google::protobuf::DescriptorPool::generated_pool());
  MemorySourceTree source_tree("person.proto", proto_content);
  google::protobuf::compiler::SourceTreeDescriptorDatabase source_tree_db(
      &source_tree);

  google::protobuf::FileDescriptorProto file_desc_proto;
  if (!source_tree_db.FindFileByName("person.proto", &file_desc_proto)) {
    std::cerr << "Failed to parse proto content!" << std::endl;
    return 1;
  }


  const google::protobuf::FileDescriptor *file_desc_dyn =
      descriptor_pool.BuildFile(file_desc_proto);
  if (!file_desc_dyn) {
    std::cerr << "Failed to build file descriptor!" << std::endl;
    return 1;
  }

  const google::protobuf::Descriptor *descriptor_dyn =
      file_desc_dyn->FindMessageTypeByName("DynamicPerson");
  if (!descriptor_dyn) {
    std::cerr << "Failed to find message descriptor!" << std::endl;
    return 1;
  }

  google::protobuf::DynamicMessageFactory factory_dyn(&descriptor_pool);
  const google::protobuf::Message *prototype =
      factory_dyn.GetPrototype(descriptor_dyn);
  if (!prototype) {
    std::cerr << "Failed to get message prototype!" << std::endl;
    return 1;
  }

  std::unique_ptr<google::protobuf::Message> message_dyn_(prototype->New());
  if (!message_dyn_) {
    std::cerr << "Failed to create dynamic message!" << std::endl;
    return 1;
  }

  // Without this, there will be seg fault
  google::protobuf::UnknownFieldSet *unknown_fields =
      message_dyn_->GetReflection()->MutableUnknownFields(message_dyn_.get());
  if (unknown_fields) {
    unknown_fields->AddVarint(999999, 0);
  }

  const google::protobuf::Reflection *reflection_dyn =
      message_dyn_->GetReflection();
  if (!reflection_dyn) {
    std::cerr << "Failed to get reflection interface!" << std::endl;
    return 1;
  }

  const google::protobuf::FieldDescriptor *name_field =
      descriptor_dyn->FindFieldByName("name");
  const google::protobuf::FieldDescriptor *age_field =
      descriptor_dyn->FindFieldByName("age");
  const google::protobuf::FieldDescriptor *hobbies_field =
      descriptor_dyn->FindFieldByName("hobbies");
  const google::protobuf::FieldDescriptor *is_active_field =
      descriptor_dyn->FindFieldByName("is_active");

  if (!name_field || !age_field || !hobbies_field || !is_active_field) {
    std::cerr << "Failed to find required fields!" << std::endl;
    return 1;
  }

  reflection_dyn->SetString(message_dyn_.get(), name_field, "John Doe");
  reflection_dyn->SetInt32(message_dyn_.get(), age_field, 30);
  reflection_dyn->SetBool(message_dyn_.get(), is_active_field, true);
  reflection_dyn->AddString(message_dyn_.get(), hobbies_field, "Reading");
  reflection_dyn->AddString(message_dyn_.get(), hobbies_field, "Hiking");
  reflection_dyn->AddString(message_dyn_.get(), hobbies_field, "Programming");

  std::cout << "\nDebug Information:\n";
  std::cout << "Message Type: " << message_dyn_->GetTypeName() << "\n";
  std::cout << "Descriptor Name: " << descriptor_dyn->full_name() << "\n";
  std::cout << "Number of Fields: " << descriptor_dyn->field_count() << "\n";
  std::cout << "Unknown Fields Size: "
            << message_dyn_->GetReflection()
                   ->GetUnknownFields(*message_dyn_)
                   .field_count()
            << "\n";

  std::cout << "\nTrying DebugString():\n";
  std::cout << message_dyn_->DebugString() << "\n\n";

  // ============================================
  // Section 8: Static vs Dynamic Message Comparison
  // Creates a static DynamicPerson message and compares its serialization
  // with the dynamic message to verify they are identical
  // ============================================
  cout << "\n=== Section 8: Static vs Dynamic Message Comparison ===\n";
  cout << "------------------------------------------\n";
  test::DynamicPerson static_person;
  static_person.set_name("John Doe");
  static_person.set_age(30);
  static_person.set_is_active(true);
  static_person.add_hobbies("Reading");
  static_person.add_hobbies("Hiking");
  static_person.add_hobbies("Programming");

  // Clear unknown fields before serialization for fair comparison
  message_dyn_->GetReflection()
      ->MutableUnknownFields(message_dyn_.get())
      ->Clear();

  std::string static_serialized, dynamic_serialized;
  static_person.SerializeToString(&static_serialized);
  message_dyn_->SerializeToString(&dynamic_serialized);

  std::cout << "Static vs Dynamic Message Comparison:\n";
  std::cout << "Serialized data identical? "
            << (static_serialized == dynamic_serialized ? "YES" : "NO") << "\n";

  if (static_serialized != dynamic_serialized) {
    std::cout << "Static serialized size: " << static_serialized.size() << "\n";
    std::cout << "Dynamic serialized size: " << dynamic_serialized.size()
              << "\n";

    // Print hex representation of both serialized messages for debugging
    std::cout << "Static serialized (hex): ";
    for (unsigned char c : static_serialized) {
      printf("%02x ", c);
    }
    std::cout << "\nDynamic serialized (hex): ";
    for (unsigned char c : dynamic_serialized) {
      printf("%02x ", c);
    }
    cout << "\n";
  }

  return 0;
}
